# Hash-Table


## Часть 2. Оптимизация


### Введение


В предыдущей части сравнивалась эффективность 7 хеш-функций. В этой части будет ускорена работа хеш-таблицы, использующей наиболее эффективную хеш-функцию из прошлой части.


### Цель


Ускорить работу хеш-таблицы, используя интринсики, ассемблерные вставки и линковку с ассемблерными функциями.


### Ход работы


Замерять время работы программы будем с помощью утилиты *perf*, профилировать будем через *valgrind* с инструментами callgrind и *KCachegrind*. Размер таблицы возьмем фиксированным и равным *9973*. Средняя длина списка составляет *6* элементов.


**Условия измерений**
- Все измерения производились с опцией -O3 компилятора gcc, а также набором инструкций AVX2.
- В коде main функция поиска вызывалась 10 000 000 раз, чтобы акцентировать на нее время работы.
- Замеры проводились при одной температуре CPU (49.8), чтобы избежать искажения показаний из-за троттлинга CPU.


#### Версия 0 (begin)


Мы изменили формат вводимых данных на двоичный, выровненный на 32 байта, чтобы ускорить и упростить считывание файла. Чтобы конвертировать свой текст в этот формат воспользуйтесь conv.exe

```
conv.exe [input-filename] [output-filename]
```

| Время работы(*мс*) | Абсолютное | Относительное | Погрешность |
|:------------------ |:---------- |:------------- |:----------- |
| 941                | 1          | 1             | 1.87%       |

*Абсолютное - ускорение, относительно версии 0. Относительное - ускорение относительно предыдущей версии. Погрешность - относительная погрешность измерения времени.*

Вывод профайлера:

![profile(begin)](assets/profile(begin).png "Profile data for version with no optimizations")

*Incl. - все время занимаемое функцией в процентах от времени работы программы. Self - время работы функции в процентах, без учета функций, вызываемых внутри нее. Called - сколько раз была вызвана функция. Function - имя функции.*


#### Версия 1 (fastcmp)


Как видно из вывода callgrind, наибольшее время занимает сравнение строк (время функций *is_equal* + *__strcmp_avx2*). Так как каждая строка выровнена на 32 байта и имеет размер кратный 32 байтам, то мы можем использовать SIMD инструкции для быстрого сравнения сразу 32 байт.

```C
while (1) {
    __m256i a = _mm256_load_si256((const __m256i *) str1);
    __m256i b = _mm256_load_si256((const __m256i *) str2);
    
    __m256i res = _mm256_sub_epi8(a, b);

    if (!_mm256_testz_si256(res, _mm256_set1_epi32(0xFFFFFFFF)))
        return 0;

    if (str1[STR_ALIGN - 1] == 0 && str2[STR_ALIGN - 1] == 0) break;
    
    str1 += STR_ALIGN, str2 += STR_ALIGN;
};

return 1;
```

| Время работы(*мс*) | Абсолютное | Относительное | Погрешность |
|:------------------ |:---------- |:------------- |:----------- |
| 832                | 1.13       | 1.13          | 1.71%       |

Вывод профайлера:

![profile(fastcmp)](assets/profile(fastcmp).png "Profile data for version with fastcmp optimization")


#### Версия 2 (crc32)


Как видно из вывода callgrind, время занимаемое is_equal уменьшилось на 18%, и наиболее затратной по времени стала функция хеширования. В предыдущих версиях мы использовали алгоритм gnu_hash, теперь мы заменим его аппаратно поддерживаемым crc32. Реализуем его с помощью директивы *asm*, которая позволяет напрямую вставлять ассемблерный код в функции C, при этом отключая встроенные в компилятор оптимизации.

```C
hash_t sum = 0;

asm(".intel_syntax noprefix     \n\t"
    "xor %0, %0                 \n\t"
    ".loop:                     \n\t"
    "crc32 %0, QWORD PTR [%1]   \n\t"
    "cmp BYTE PTR [%1+7], 0     \n\t"
    "je .finish                 \n\t"
    "add %1, 8                  \n\t"
    "jmp .loop                  \n\t"
    ".finish:                   \n\t"
    :"=r"(sum)
    :"r"(key)
    :"cc"
);

return sum;
```

| Время работы(*мс*) | Абсолютное | Относительное | Погрешность |
|:------------------ |:---------- |:------------- |:----------- |
| 703                | 1.31       | 1.18          | 3.57%       |

Вывод профайлера:

![profile(crc32)](assets/profile(crc32).png "Profile data for version with crc32 optimization")


#### Версия 3 (find_node)


Как видно из вывода callgrind, время занимаемое функцией хеширования уменьшилось на 28%, что вывело на первое место по временным затратам функцию поиска в связном списке. Мы напишем свою ассемблерную реализацию этой функции. Так как компилятор генерирует код для общего случая, то наша специализированная реализация будет быстрее. Для ознакомления приведем фрагмент реализации цикла, полный код можно найти в файле *source/find_node.s*.

```assembly
asm_find_node:
    ; Loop
    jmp .condition

.loop:
    mov r15, r12            ; prev_ = begin

    mov r12, [r12+16]       ; begin = begin -> next

    ; Check if begin is NULL
    test r12, r12
    je .restore             ; We don't need to set prev to prev_, cause nothing was found

.condition:
    ; Call is_equal
    mov rdi, [r12]
    mov rsi, r13
    call is_equal

    test rax, rax           ; Check if is_equal return zero
    je .loop

    ; Set prev to prev_
    test r14, r14
    je .restore             ; Caller doesn't need previous node

    mov [r14], r15          ; *prev = prev_
```

| Время работы(*мс*) | Абсолютное | Относительное | Погрешность |
|:------------------ |:---------- |:------------- |:----------- |
| 683                | 1.34       | 1.03          | 2.02%       |

Вывод профайлера:

![profile(find_node)](assets/profile(find_node).png "Profile data for version with find_node optimization")

Наша функция (*функция по адресу 0x402400*) смогла обогнать реализацию -O3 всего на 3%. Дальнейшие ассемблерные оптимизации не имеют смысла и только навредят портируемости программы.


### Результат


Приведем итоговое ускорение относительно начальной версии:

| Время работы(*мс*) | Абсолютное ускорение |  Погрешность |
|:------------------ |:-------------------- |:------------ |
| 683                | 1.34                 | 3.87%        |


### Вывод


Использование различных ассемблерных оптимизаций позволило ускорить работу хеш-таблицы на 34%. Однако такие оптимизации портят портируемость кода и требуют индивидуального подхода к конкретному случаю.
