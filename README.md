# Hash-Table


## Часть 2. Оптимизация


### Введение


В предыдущей части сравнивалась эффективность 7 хеш-функций. В этой части будет ускорена работа хеш-таблицы, использующей наиболее эффективную хеш-функцию из прошлой части.


### Цель


Ускорить работу хеш-таблицы, используя интринсики, ассемблерные вставки и линковку с ассемблерными функциями.


### Ход работы


Замерять время работы программы будем с помощью утилиты *perf*, профилировать будем через *valgrind* с инструментами callgrind и *KCachegrind*. Размер таблицы возьмем фиксированным и равным *1009*.


#### Версия 0 (begin)


Мы изменили формат вводимых данных на двоичный, выровненный на 32 байта, чтобы ускорить и упростить считывание файла. Чтобы конвертировать свой текст в этот формат воспользуйтесь conv.exe

```
conv.exe [input-filename] [output-filename]
```

| Время работы(*мс*) | Абсолютное | Относительное | Среднеквадратическое |
|:------------------ |:---------  |:------------- |:-------------------- |
| 4311               | 1          | 1             | 80                   |

Вывод профайлера:

![profile(begin)](assets/profile(begin).png "Profile data for version with no optimizations")


#### Версия 1 (fastcmp)


Как видно из вывода callgrind, наибольшее время занимает сравнение строк (время функции *is_equal* + *__strcmp_avx2*). Так как каждая строка выровнена на 32 байта и имеет размер кратный 32 байтам, то мы можем использовать SIMD инструкции для быстрого сравнения сразу 32 байт.

```C
while (1) {
    __m256i a = _mm256_load_si256((const __m256i *) str1);
    __m256i b = _mm256_load_si256((const __m256i *) str2);
    
    __m256i res = _mm256_sub_epi8(a, b);

    if (!_mm256_testz_si256(res, _mm256_set1_epi32(0xFFFFFFFF)))
        return 0;

    if (str1[STR_ALIGN - 1] == 0 && str2[STR_ALIGN - 1] == 0) break;
    
    str1 += STR_ALIGN, str2 += STR_ALIGN;
};

return 1;
```

| Время работы(*мс*) | Абсолютное | Относительное | Среднеквадратическое |
|:------------------ |:---------  |:------------- |:-------------------- |
| 3919               | 1.1        | 1.1           | 50                   |

Вывод профайлера:

![profile(fastcmp)](assets/profile(fastcmp).png "Profile data for version with fastcmp optimization")


#### Версия 2 (find_node)


Как видно из вывода callgrind, время занимаемое is_equal уменьшилось на 24%, поэтому оптимизировать его дальше не имеет смысла. Следующим идет поиск в связном списке. Мы напишем свою ассемблерную реализацию этой функции. Так как компилятор генерирует код для общего случая, то наша специализированная реализация будет быстрее. Для ознакомления приведем фрагмент реализации цикла, полный код можно найти в файле *source/find_node.s*.

```assembly
asm_find_node:
    ; Loop
    jmp .condition

.loop:
    mov r15, r12            ; prev_ = begin

    mov r12, [r12+16]       ; begin = begin -> next

    ; Check if begin is NULL
    test r12, r12
    je .restore             ; We don't need to set prev to prev_, cause nothing was found

.condition:
    ; Call is_equal
    mov rdi, [r12]
    mov rsi, r13
    call is_equal

    test rax, rax           ; Check if is_equal return zero
    je .loop

    ; Set prev to prev_
    test r14, r14
    je .restore             ; Caller doesn't need previous node

    mov [r14], r15          ; *prev = prev_
```

| Время работы(*мс*) | Абсолютное | Относительное | Среднеквадратическое |
|:------------------ |:---------- |:------------- |:-------------------- |
| 3839               | 1.12       | 1.02          | 68                   |

Вывод профайлера:

![profile(find_node)](assets/profile(find_node).png "Profile data for version with find_node optimization")


#### Версия 3 (crc32)


Как видно из вывода callgrind, время занимаемое поиском элемента уменьшилось на 2%, поэтому оптимизировать его дальше не имеет смысла (в предыдущей версии функция называлась c_find_node, здесь это функция по адресу 0x402410). Следующей идет функция хеширования. В предыдущих версиях мы использовали алгоритм gnu_hash, теперь мы заменим его аппаратно поддерживаемым crc32. Реализуем его с помощью директивы *asm*, которая позволяет напрямую вставлять ассемблерный код в функции C, при этом отключая встроенные в компилятор оптимизации.

```C
hash_t sum = 0;

asm(".intel_syntax noprefix     \n\t"
    "xor %0, %0                 \n\t"
    ".loop:                     \n\t"
    "crc32 %0, QWORD PTR [%1]   \n\t"
    "cmp BYTE PTR [%1+7], 0     \n\t"
    "je .finish                 \n\t"
    "add %1, 8                  \n\t"
    "jmp .loop                  \n\t"
    ".finish:                   \n\t"
    :"=r"(sum)
    :"r"(key)
    :"cc"
);

return sum;
```

| Время работы(*мс*) | Абсолютное | Относительное | Среднеквадратическое |
|:------------------ |:---------- |:------------- |:-------------------- |
| 3744               | 1.15       | 1.03          | 139                  |

Вывод профайлера:

![profile(crc32)](assets/profile(crc32).png "Profile data for version with crc32 optimization")


### Результат

**Условия**
- Все измерения производились с опцией -O3 компилятора gcc, а также набором инструкций AVX2.
- В коде main функция поиска вызывалась 10 000 000 раз, чтобы акцентировать на нее время работы.
- Компьютер был подключен к сети, чтобы система не снимала нагрузку с CPU для экономии заряда.
- Замеры проводились при одной температуре CPU (49.8), чтобы избежать искажения показаний из-за троттлинга CPU.

**Итог**:

| Время работы(*мс*) | Абсолютное ускорение |  Среднеквадратическое |
|:------------------ |:-------------------- |:--------------------- |
| 3744               | 1.15                 | 139                   |


### Вывод


Использование различных ассемблерных оптимизаций позволило ускорить работу хеш-таблицы в 1.15 раз. Однако такие оптимизации портят портируемость кода и требуют индивидуального подхода к конкретному случаю.
